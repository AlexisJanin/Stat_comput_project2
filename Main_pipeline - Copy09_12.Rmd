---
title: "R Notebook"
output: html_notebook
---

```{r packages}
library(MASS)
library(locpol)
library(functClust)
library(lpridge)
library(lokern)
library(KernSmooth)
library(locfit)
library(stats)
source("functions.R")
```

```{r parameters that we can compare}
K <- 10                             #Number of folds
d <- 2                              #Degree(s)
h <- 0.5                            #Bandwidth(s)
N_xeval <- 1000                           #Sizes of sample

Samples_sizes <- 10^(1:3); s <- length(Samples_sizes) #length(xeval) < 5000 in locpol that's why 3 here atm
time_locpol <- 1:s*0
time_locfit <- 1:s*0
time_locpoly <- 1:s*0
time_ksmooth <- 1:s*0

n_method = 3
n_trials = 1
nb_functions = 1

nrow = s*n_method*n_trials*length(h)*length(d)*nb_functions
df_results <- data.frame(matrix(nrow = nrow,ncol = 8))
colnames(df_results) <- c("Indice","Degree","Bandwidth","Number_of_input_points","Method","Function","Time","Error") #Dataframe to fill
df_results$Indice <- 1:nrow

#ind <- matrix(sample(1:N),ncol=K)   #Pipeline for dividing the sample
```

```{r MAIN function}
err_time_comput <- function(degree = 1, bandwidth = 1,X,Y_noisy,X_eval,fct, method = "locpol"){
  time = 0
  error = 0
  if (method=="locpol"){
      time <- Sys.time()
      y_locpol <- locpol(Y_noisy~X,data.frame(X,Y_noisy),bw = bandwidth,deg = degree,kernel = gaussK,xeval = X_eval)         #xeval has to be < 5000 length.... and also X ???
      time <- Sys.time()-time
      #TODO
  }
  if (method=="locpoly"){
    #TODO
  }
  if (method=="locfit"){
    #TODO
  }
  
  return(time,error)
}


```




```{r Time comparison}
t <- c(0,0,0)
i <- 1
for (n in df_results$Samples_sizes){
  set.seed(1)
  X <- 0:n/(n/5)                      #To go from 0 to 5
  X_eval = 0:N_xeval/(N_xeval/5)            #X_eval, we accorded on 100 or 1000 or 5000 points; shouldn't matter                                        much!
  Y <- dmixnorm(X,mu1 = 4)            #Simply change de the function for the one wanted
  Y_noisy <- Noise_induction(Y,sig_gauss = abs(max(Y)-min(Y))/10)  #Variance of gaussian noise linearly correlated with TV(total variation of a function) so the noise is not too low or too big
  
  t[1] <- Sys.time()
  y_locpol <- locpol(Y_noisy~X,data.frame(X,Y_noisy),bw = h,deg = d,kernel = gaussK,xeval = X_eval)  #xeval has to be < 5000....
  t[1] <- Sys.time()-t[1]
  
  t[2] <- Sys.time()
  y_locpoly <- locpoly(X,Y_noisy, bandwidth=h, degree=d,gridsize = N_xeval) 
  t[2] <- Sys.time()-t[2]
  
  t[3] <- Sys.time()
  y_locfit <- locfit(X~lp(Y_noisy,h=h/2,deg=d),data.frame(X,Y_noisy), kern = 'gauss') #TODO: check if bandwidth has indeed to be treated like that
  t[3] <- Sys.time()-t[3]
  
  #t[4] <- Sys.time()  
  #y_ksmooth <- ksmooth(X,Y_noisy, bandwidth=h, kernel = "normal",X) #NO DEGREE
  #t[4] <- Sys.time() - t[4]
  
  df_results[i,-1] <- t
  print(i)
  i <- i+1
  
}
```
```{r}
#Plotting locpol 
#lines(y_locpol[["lpFit"]][["X"]],y_locpol[["lpFit"]][["Y_noisy"]],col = "red")
```







