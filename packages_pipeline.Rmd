---
title: "Project 1 working document for pipeline following the packages"
output: html_notebook
---

```{r packages}
library(MASS)
library(locpol)
library(functClust)
library(lpridge)
library(lokern)
library(KernSmooth)
library(locfit)
library(stats)
```


```{r parameters that we can compare}
K <- 13                             #Number of folds
d <- 2                              #Degree
h <- 3                              #Bandwidth
N_sub <- 112                        #Number of points
```


```{r data import and K strat definition,warning = FALSE}

data(mcycle)
mcycle <- mcycle[mcycle$times <= 40, ]
mcycle <- mcycle[sample(nrow(mcycle),N_sub), ]
#plot(mcycle$times,mcycle$accel)

set.seed(101)
N <- nrow(mcycle)

ind <- matrix(sample(1:N),ncol=K)   #dividing the sample

```

```{r not so smooth function definition that we will try to approximate}
dmixnorm <- function(x, mu1 = 0, mu2 = 2, sigma1 = 1, sigma2 = 3, tau = 0.7){   #Rather very smooth
  y <- (1-tau)*dnorm(x,mu1,sigma1) + tau*dnorm(x,mu2,sigma2)
  return(y)
}

log_sin <- function(x,a = 5, b = 1.05){  #Not smooth at all  the smaller a is, the smoother it is
  if(b<1){print('b>1 or error!!')
    break}
  return(log(sin(a*x)+b))
}

x = 0:1000/100
plot(x,log_sin(x))


```


```{r Noise induction}
Noise_induction <- function(X,type = 'gauss',uniform = TRUE,sig_gauss = 1, mu_gauss = 0,r_unif = 0.25){
  #Type (='gauss') : Type of the noise considered: 'gauss'(default); 'unif'
  #Uniform (=TRUE) : False if the noise is growing (in variance) along with X-axis growing
  #sig_gauss, mu_gauss (=(0,1)): in case of gaussian noise
  #r_unif (=0.25): range of uniform noise in case of type='unif' : [-r_unif,r_unif]
  
  if(type=='gauss'){
    if(uniform){
      n <- rnorm(length(X),mu_gauss,sig_gauss)
      return(X+n)
    }
    #if uniform = False fill
  }
  
  if(type=='unif'){
    if(uniform){
      n <- runif(length(X),min = -r_unif,max = r_unif)
      return(X+n)
    }
    #if uniform = False fill
  }
    
  return(X)
}


```




```{r locpol}
#Clear degree, clear bandwidth and clear kernel.
interpol <- function(time_in,time_pred,accel_pred,y){  #I don't understand how to compute                                                                  the function m(x)
l = length(time_in)  
acc = 1:l
accel_diff = 1:l
  for (i in 1:l){
  acc[i] = which.min(abs(time_pred-time_in[i]))
  accel_diff[i] = abs(accel_pred[acc[i]]-y[i])/l
  }
return(sum(accel_diff))
}


error_locpol = 0
for (k in 1:K){
  y <- locpol(accel ~ times,mcycle[-ind[,k],],bw = h,deg = d,kernel = gaussK,xeval = (24:400)/10)  #Instead of this two lines i can simply take xeval = the points that i want! (but then care about the indices)
  error_locpol = error_locpol + interpol(time_in = mcycle$times[ind[,k]],y = mcycle$accel[ind[,k]],accel_pred = y$lpFit$accel,time_pred = y$lpFit$times)
    }
    error_locpol = error_locpol/K
    print(error_locpol)
    
y <- locpol(accel ~ times,mcycle,bw = h,deg = d,kernel = gaussK,xeval = (24:400)/10) 
plot(y)
```

```{r loess}
#Clear degree, unclear bandwidth and no kernel.
error_loess = 0
for (k in 1:K){
  y_lo <- loess(accel~times, mcycle[-ind[,k],],degree = d,span = 0.35)  #Don't really understand how to compare h and span
  error_loess = error_loess + sum(abs(predict(y_lo,mcycle$times[ind[,k]])-mcycle$accel[ind[,k]]),na.rm = TRUE)/k
    }
    error_loess = error_loess/K
    print(error_loess)
    
    
y_lo <- loess(accel~times, mcycle,degree = d,span = 0.35)
plot(mcycle$times,mcycle$accel)
points(mcycle$times,predict(y_lo,mcycle$times))
```

```{r}
#Clear degree, clear bandwidth and clear kernel but only Epa.
error_lpepa = 0
mcycle <- mcycle[order(mcycle$times),]  #Ordering the data set, this is not an issue since the indices are still random
for (k in 1:K){
  y_lpepa <- lpepa(mcycle$times[-ind[,k]],mcycle$accel[-ind[,k]],bandwidth = h,order = d,x.out = mcycle$times[ind[,k]])
  #x_out_not_ordered = mcycle$times[ind[,k]]
  #print(mcycle$times[ind[,k]])
  error_lpepa = error_lpepa + sum(abs(y_lpepa$est-mcycle$accel[sort(ind[,k])]),na.rm = TRUE)/k
    }
    error_lpepa = error_lpepa/K #Way to high recheck the computation of error
    print(error_lpepa)
    

y_lpepa <- lpepa(mcycle$times,mcycle$accel,bandwidth = h,order = d,x.out = mcycle$times)
plot(y_lpepa$x.out,y_lpepa$est)
points(mcycle$times,mcycle$accel,col = "red")
```

```{r}
#Clear degree, clear bandwidth and UNclear kernel.
error_lokerns = 0
mcycle <- mcycle[order(mcycle$times),]  #Ordering the data set, this is not an issue since the indices are still random
for (k in 1:K){
  y_lokerns <- lokerns(mcycle$times[-ind[,k]],mcycle$accel[-ind[,k]],bandwidth = ((1:length(mcycle$accel[ind[,k]]))*0)+h,korder = d,x.out = mcycle$times[ind[,k]])
  #x_out_not_ordered = mcycle$times[ind[,k]]
  #print(mcycle$times[ind[,k]])
  error_lokerns = error_lokerns + sum(abs(y_lokerns$est-mcycle$accel[sort(ind[,k])]),na.rm = TRUE)/k
    }
    error_lokerns = error_lokerns/K #Way to high recheck the computation of error
    print(error_lokerns)
    

y_lokerns <- lokerns(mcycle$times,mcycle$accel,bandwidth = ((1:length(mcycle$accel))*0)+h,korder = d,x.out = mcycle$times)
plot(y_lokerns$x.out,y_lokerns$est)
points(mcycle$times,mcycle$accel,col = "red")
```

```{r}
#Clear degree, unclear bandwidth and clear kernel.
errorlocfit <- 0
for (k in 1:K){
  lf <- locfit(accel~lp(times,h=h*2), data=mcycle[-ind[,k],], deg=d,kern = "gauss")
  preds <- predict(lf, newdata=mcycle[ind[,k],], se.fit=TRUE)$fit
  errorlocfit <- errorlocfit + sum(abs(mcycle$accel[ind[,k]] - preds))/k
}
errorlocfit/K

lf <- locfit(accel~lp(times,h=h*2), data=mcycle, deg=d,kern = "gauss")  #it seems like since h is the halfradius,
preds <- predict(lf, newdata=mcycle, se.fit=TRUE)$fit
plot(mcycle$times,mcycle$accel,col = "red")
lines(mcycle$times,preds)

```

```{r}
#Clear degree, clear bandwidth and clear kernel.
errorkern = 0
for (k in 1:K){
  lp <- locpoly(x = mcycle$times[-ind[,k]],y = mcycle$accel[-ind[,k]], bandwidth=h, degree=2)
  l <- length(mcycle$times[ind[,k]])
  cverror <- 0
  for (i in 1:l){
    gg <- mcycle$times[ind[,k]][i]
    preds <- lp$y[which.min(abs(lp$x - gg))] 
    cverror <- cverror + abs(gg- preds)/k
  }
  errorkern <- errorkern + cverror
}
errorkern/K

y_locpoly <- locpoly(x = mcycle$times,y = mcycle$accel, bandwidth=h, degree=2,gridsize = N_sub)

plot(mcycle$times,mcycle$accel,col = "red")
lines(y_locpoly)
```


```{r}
#Clear degree, clear bandwidth and clear kernel.
errorksmooth = 0
for (k in 1:K){
  lp <- ksmooth(x = mcycle$times[-ind[,k]],y = mcycle$accel[-ind[,k]], bandwidth=h, kernel = "normal", x.points = mcycle$times[ind[,k]])
  l <- length(mcycle$times[ind[,k]])
  cverror <- sum(abs(lp$y-mcycle$accel[ind[,k]]))/k
  errorksmooth <- errorksmooth + cverror
}
errorksmooth/K

y_ksmooth <- ksmooth(x = mcycle$times,y = mcycle$accel, bandwidth=h, kernel = "normal",x.points = mcycle$times)

plot(mcycle$times,mcycle$accel,col = "red")
lines(y_ksmooth$x,y_ksmooth$y)
```
```{r}
source("functions.R")
```














